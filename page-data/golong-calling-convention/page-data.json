{"componentChunkName":"component---src-templates-blog-post-js","path":"/golong-calling-convention/","result":{"data":{"site":{"siteMetadata":{"title":"블로그 공사중"}},"markdownRemark":{"id":"2a8416d8-e457-574a-9747-7e11c17d1ae4","excerpt":"친구들과 잡담을 하던 도중, 이런 흥미로운 이야기를 들었다. go로 짜면 리버싱이 개어렵긴하더라. go…","html":"<p>친구들과 잡담을 하던 도중, 이런 흥미로운 이야기를 들었다.</p>\n<blockquote>\n<p>go로 짜면 리버싱이 개어렵긴하더라. go가 진짜 개악질인게 우리가 아는 표준 콜링컨벤션을 하나도 안 지킴. 레지스터를 지 맘대로 씀. 심지어 버전마다도 조금씩 다르다니까?</p>\n</blockquote>\n<p>처음 들어보는 재밌는 이야기여서 확인차 적어보고자 한다.</p>\n<h2>Calling convention이란?</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.16455696202532%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJUlEQVR42nWT3WvTUBjG+4/6N3gvIt54NUG8EwSHqMgUvZm0rKKIYNtNpHNsa7t+bqZfJ81JTj5O0iTtT3Kcdcp84CXk5Jzfm/fJk1K9XqdWq1Eul8314OCARqNBtVrl8PCQ67Rer6+tQqVkuWSZJKRxTKw1aZqayvOc1WplNhX3y+WSLMvM+v9UQEvtk2NOj4/pHB0xn81Qvo9SyjwsQFovkVIynU4JgoAoipjP5wZQNEnSDK31pnlpOraYjC3GYwsh5ijl4XneJewNQfCKPE+p1xtUKmUWi4VpKhc2s+oLRL1iXqSAGuCgN6Tb7jHonzOZCmzbRUqfNM0IgocodZss0+zvf2V3dxchhDmoPBexfYfFzhatVovRaPQL2Gt/4qhZZTDcx7KaTCZNPO8MrSO63Zv0ejdI05DxeEK/3zM+FuP/uLggevsA/90jXM/b+Fhy5AmO00bKFlK28f02YdQ1/vj+fVzvFkkSms22LRgOhwboOAuSD8+JPr9mLoRZS+KY0mzqIoTCkRHOIsRxIqIoJ89XaP0Yre+R54kBxrGm3+8jbBsdRfjVp6iPOwwGAzqdDnEBbHfqnHW/ICanSDlEyj6ed27isV5nrFbyr5wV8oMAz3WZbN/FerllPkjhuRl5ONrj/GIPKWr4QROlvqHUd/I8+zdlG3AYRgRhiHr/DLfyhPwyMiaHliUQtksQFJ4lmypGvgq5Gt7fytewMpP8+VN+ApgCODpMfSPuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"calling_convention.png\"\n        title=\"\"\n        src=\"/static/7e5de6104d5b24d87669ba922dc54931/f058b/calling_convention.png\"\n        srcset=\"/static/7e5de6104d5b24d87669ba922dc54931/c26ae/calling_convention.png 158w,\n/static/7e5de6104d5b24d87669ba922dc54931/6bdcf/calling_convention.png 315w,\n/static/7e5de6104d5b24d87669ba922dc54931/f058b/calling_convention.png 630w,\n/static/7e5de6104d5b24d87669ba922dc54931/40601/calling_convention.png 945w,\n/static/7e5de6104d5b24d87669ba922dc54931/78612/calling_convention.png 1260w,\n/static/7e5de6104d5b24d87669ba922dc54931/d5eae/calling_convention.png 1407w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<a href=\"https://twitter.com/konradkokosa/status/1435142226422779904\">출처</a></p>\n<p>말 그대로 \"호출 규약\"이다. 함수를 호출할 때 어떤 방법으로 진행하는지에 대한 약속들을 정리해 놓은 것.\n매개 변수들을 서브루틴에 어떻게 전달할 지, 호출자(caller)가 레지스터의 내용이 보존되기를 원하는지,\n서브루틴의 로컬 변수는 어디에 저장해야 할 지, 결과 반환은 어떻게 해야 할 지 등의 다양한 결정들을 해야 하는데,\n통일된 호출 규칙을 만들어서 사용하면 훨씬 편하게 서브루틴을 정의하고 사용할 수 있다.</p>\n<p>통일된 호출 규칙을 사용하면, 각 서브루틴이 어떻게 매개변수를 전달해야 하는지를 일일히 살펴 볼 필요가 없고,\n컴파일러가 해당 규칙을 따르기 때문에 직접 어셈블리를 짜더라도 서로의 루틴을 호출할 수 있다.</p>\n<h2>직접 알아보자</h2>\n<p>먼저 c로 간단한 코드를 짜 보자:</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">#include &lt;stdio.h&gt;\n\nint sum(int a, int b) {\n    return a+b;\n}\n\n\nint main() {\n    int a;\n    a = sum(1, 1);\n    printf(&quot;%d\\n&quot;, a);\n    return 0;\n}</code>\n        </deckgo-highlight-code>\n<p>어셈블리로 분석해 보면 다음과 같은 코드가 나온다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">(gdb) disas main\nDump of assembler code for function main:\n   0x0000000000001161 &lt;+0&gt;:     endbr64\n   0x0000000000001165 &lt;+4&gt;:     push   %rbp\n   0x0000000000001166 &lt;+5&gt;:     mov    %rsp,%rbp\n   0x0000000000001169 &lt;+8&gt;:     sub    $0x10,%rsp\n   0x000000000000116d &lt;+12&gt;:    mov    $0x1,%esi\n   0x0000000000001172 &lt;+17&gt;:    mov    $0x1,%edi\n   0x0000000000001177 &lt;+22&gt;:    call   0x1149 &lt;sum&gt;\n   0x000000000000117c &lt;+27&gt;:    mov    %eax,-0x4(%rbp)\n   0x000000000000117f &lt;+30&gt;:    mov    -0x4(%rbp),%eax\n   0x0000000000001182 &lt;+33&gt;:    mov    %eax,%esi\n   0x0000000000001184 &lt;+35&gt;:    lea    0xe79(%rip),%rax        # 0x2004\n   0x000000000000118b &lt;+42&gt;:    mov    %rax,%rdi\n   0x000000000000118e &lt;+45&gt;:    mov    $0x0,%eax\n   0x0000000000001193 &lt;+50&gt;:    call   0x1050 &lt;printf@plt&gt;\n   0x0000000000001198 &lt;+55&gt;:    mov    $0x0,%eax\n   0x000000000000119d &lt;+60&gt;:    leave\n   0x000000000000119e &lt;+61&gt;:    ret\nEnd of assembler dump.\n(gdb) disas sum\nDump of assembler code for function sum:\n   0x0000000000001149 &lt;+0&gt;:     endbr64\n   0x000000000000114d &lt;+4&gt;:     push   %rbp\n   0x000000000000114e &lt;+5&gt;:     mov    %rsp,%rbp\n   0x0000000000001151 &lt;+8&gt;:     mov    %edi,-0x4(%rbp)\n   0x0000000000001154 &lt;+11&gt;:    mov    %esi,-0x8(%rbp)\n   0x0000000000001157 &lt;+14&gt;:    mov    -0x4(%rbp),%edx\n   0x000000000000115a &lt;+17&gt;:    mov    -0x8(%rbp),%eax\n   0x000000000000115d &lt;+20&gt;:    add    %edx,%eax\n   0x000000000000115f &lt;+22&gt;:    pop    %rbp\n   0x0000000000001160 &lt;+23&gt;:    ret\nEnd of assembler dump.</code>\n        </deckgo-highlight-code>\n<p>일반적으로 리눅스에서는 인자를 rdi에 넣는다.\n위 어셈 코드를 보면 esi와 edi(rdi를 반으로 나눈 게 edi다. rdi는 64bit, edi는 32bit)에 각각 값(1)을 넣은 뒤,\nsum 함수를 콜하는 것을 볼 수 있다.</p>\n<p>그럼 go로 비슷한 코드를 써 보자:</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">package main\nimport (\n    &quot;fmt&quot;\n)\nfunc sum(a int, b int) int {\n    return a+b\n}\n\nfunc main() {\n    a := sum(1, 1)\n    fmt.Printf(&quot;%d\\n&quot;, a)\n}</code>\n        </deckgo-highlight-code>\n<p>어셈블리로 분석해 보면?</p>\n<p>먼저 어떤 함수들이 있는지 보자.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">(gdb) info functions\nAll defined functions:\n\nFile /home/mango/coding/lab/main.go:\n        void main.main(void);\n\nFile /usr/lib/go-1.18/src/errors/errors.go:\n        void errors.(*errorString).Error;\n\nFile /usr/lib/go-1.18/src/errors/wrap.go:\n        void errors.init(void);\n\nFile /usr/lib/go-1.18/src/fmt/format.go:\n        void fmt.(*fmt).fmtBoolean;\n        void fmt.(*fmt).fmtBs;\n...</code>\n        </deckgo-highlight-code>\n<p>어라? main.go에 함수가 하나밖에 없다. 최적화로 지워진 모양이다.</p>\n<p>main.main을 들어가 보자.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">(gdb) disas main.main\nDump of assembler code for function main.main:\n   0x000000000047f460 &lt;+0&gt;:     cmp    0x10(%r14),%rsp\n   0x000000000047f464 &lt;+4&gt;:     jbe    0x47f4cf &lt;main.main+111&gt;\n   0x000000000047f466 &lt;+6&gt;:     sub    $0x50,%rsp\n   0x000000000047f46a &lt;+10&gt;:    mov    %rbp,0x48(%rsp)\n   0x000000000047f46f &lt;+15&gt;:    lea    0x48(%rsp),%rbp\n   0x000000000047f474 &lt;+20&gt;:    movups %xmm15,0x38(%rsp)\n   0x000000000047f47a &lt;+26&gt;:    mov    $0x2,%eax\n   0x000000000047f47f &lt;+31&gt;:    nop\n   0x000000000047f480 &lt;+32&gt;:    call   0x409820 &lt;runtime.convT64&gt;\n   0x000000000047f485 &lt;+37&gt;:    lea    0x7394(%rip),%rcx        # 0x486820\n   0x000000000047f48c &lt;+44&gt;:    mov    %rcx,0x38(%rsp)\n   0x000000000047f491 &lt;+49&gt;:    mov    %rax,0x40(%rsp)\n   0x000000000047f496 &lt;+54&gt;:    mov    0xa2ad3(%rip),%rbx        # 0x521f70 &lt;os.Stdout&gt;\n   0x000000000047f49d &lt;+61&gt;:    lea    0x34d94(%rip),%rax        # 0x4b4238 &lt;go.itab.*os.File,io.Writer&gt;\n   0x000000000047f4a4 &lt;+68&gt;:    lea    0x166ef(%rip),%rcx        # 0x495b9a\n   0x000000000047f4ab &lt;+75&gt;:    mov    $0x3,%edi\n   0x000000000047f4b0 &lt;+80&gt;:    lea    0x38(%rsp),%rsi\n   0x000000000047f4b5 &lt;+85&gt;:    mov    $0x1,%r8d\n   0x000000000047f4bb &lt;+91&gt;:    mov    %r8,%r9\n   0x000000000047f4be &lt;+94&gt;:    xchg   %ax,%ax\n   0x000000000047f4c0 &lt;+96&gt;:    call   0x478ca0 &lt;fmt.Fprintf&gt;\n   0x000000000047f4c5 &lt;+101&gt;:   mov    0x48(%rsp),%rbp\n   0x000000000047f4ca &lt;+106&gt;:   add    $0x50,%rsp\n   0x000000000047f4ce &lt;+110&gt;:   ret\n   0x000000000047f4cf &lt;+111&gt;:   call   0x458980 &lt;runtime.morestack_noctxt&gt;\n   0x000000000047f4d4 &lt;+116&gt;:   jmp    0x47f460 &lt;main.main&gt;\nEnd of assembler dump.</code>\n        </deckgo-highlight-code>\n<p>...이게 뭐지?</p>\n<h2>어지럽다</h2>\n<p>함수가 갑자기 사라진 건 최적화의 영향이라고 생각해서, <code>-gcflags '-N'</code> 을 사용해서 최적화를 꺼 보았다. 그랬더니...</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">(gdb) disas main.main\nDump of assembler code for function main.main:\n   0x000000000047f460 &lt;+0&gt;:     lea    -0x70(%rsp),%r12\n   0x000000000047f465 &lt;+5&gt;:     cmp    0x10(%r14),%r12\n   0x000000000047f469 &lt;+9&gt;:     jbe    0x47f625 &lt;main.main+453&gt;\n   0x000000000047f46f &lt;+15&gt;:    sub    $0xf0,%rsp\n   0x000000000047f476 &lt;+22&gt;:    mov    %rbp,0xe8(%rsp)\n   0x000000000047f47e &lt;+30&gt;:    lea    0xe8(%rsp),%rbp\n   0x000000000047f486 &lt;+38&gt;:    movq   $0x1,0x50(%rsp)\n   0x000000000047f48f &lt;+47&gt;:    movq   $0x1,0x48(%rsp)\n   0x000000000047f498 &lt;+56&gt;:    mov    0x50(%rsp),%rcx\n   0x000000000047f49d &lt;+61&gt;:    inc    %rcx\n   0x000000000047f4a0 &lt;+64&gt;:    mov    %rcx,0x38(%rsp)\n   0x000000000047f4a5 &lt;+69&gt;:    jmp    0x47f4a7 &lt;main.main+71&gt;\n   0x000000000047f4a7 &lt;+71&gt;:    mov    %rcx,0x58(%rsp)\n   0x000000000047f4ac &lt;+76&gt;:    lea    0x166e7(%rip),%rcx        # 0x495b9a\n   0x000000000047f4b3 &lt;+83&gt;:    mov    %rcx,0x80(%rsp)\n   0x000000000047f4bb &lt;+91&gt;:    movq   $0x3,0x88(%rsp)\n   0x000000000047f4c7 &lt;+103&gt;:   movups %xmm15,0xa0(%rsp)\n   0x000000000047f4d0 &lt;+112&gt;:   lea    0xa0(%rsp),%rcx\n   0x000000000047f4d8 &lt;+120&gt;:   mov    %rcx,0x78(%rsp)\n   0x000000000047f4dd &lt;+125&gt;:   mov    0x58(%rsp),%rax\n   0x000000000047f4e2 &lt;+130&gt;:   call   0x409820 &lt;runtime.convT64&gt;\n   0x000000000047f4e7 &lt;+135&gt;:   mov    %rax,0x70(%rsp)\n   0x000000000047f4ec &lt;+140&gt;:   mov    0x78(%rsp),%rcx\n   0x000000000047f4f1 &lt;+145&gt;:   test   %al,(%rcx)\n   0x000000000047f4f3 &lt;+147&gt;:   lea    0x7326(%rip),%rdx        # 0x486820\n   0x000000000047f4fa &lt;+154&gt;:   mov    %rdx,(%rcx)\n   0x000000000047f4fd &lt;+157&gt;:   lea    0x8(%rcx),%rdi\n   0x000000000047f501 &lt;+161&gt;:   cmpl   $0x0,0xd1c08(%rip)        # 0x551110 &lt;runtime.writeBarrier&gt;\n   0x000000000047f508 &lt;+168&gt;:   je     0x47f50c &lt;main.main+172&gt;\n   0x000000000047f50a &lt;+170&gt;:   jmp    0x47f512 &lt;main.main+178&gt;\n   0x000000000047f50c &lt;+172&gt;:   mov    %rax,0x8(%rcx)\n   0x000000000047f510 &lt;+176&gt;:   jmp    0x47f519 &lt;main.main+185&gt;\n   0x000000000047f512 &lt;+178&gt;:   call   0x45a940 &lt;runtime.gcWriteBarrier&gt;\n   0x000000000047f517 &lt;+183&gt;:   jmp    0x47f519 &lt;main.main+185&gt;\n   0x000000000047f519 &lt;+185&gt;:   mov    0x78(%rsp),%rdx\n   0x000000000047f51e &lt;+190&gt;:   test   %al,(%rdx)\n   0x000000000047f520 &lt;+192&gt;:   jmp    0x47f522 &lt;main.main+194&gt;\n   0x000000000047f522 &lt;+194&gt;:   mov    %rdx,0xd0(%rsp)\n   0x000000000047f52a &lt;+202&gt;:   movq   $0x1,0xd8(%rsp)\n   0x000000000047f536 &lt;+214&gt;:   movq   $0x1,0xe0(%rsp)\n   0x000000000047f542 &lt;+226&gt;:   movq   $0x0,0x40(%rsp)\n   0x000000000047f54b &lt;+235&gt;:   movups %xmm15,0x90(%rsp)\n   0x000000000047f554 &lt;+244&gt;:   movq   $0x0,0x68(%rsp)\n   0x000000000047f55d &lt;+253&gt;:   movups %xmm15,0xc0(%rsp)\n   0x000000000047f566 &lt;+262&gt;:   movups %xmm15,0xb0(%rsp)\n   0x000000000047f56f &lt;+271&gt;:   mov    0x80(%rsp),%rcx\n   0x000000000047f577 &lt;+279&gt;:   mov    0xd0(%rsp),%rsi\n   0x000000000047f57f &lt;+287&gt;:   mov    0xd8(%rsp),%r8\n   0x000000000047f587 &lt;+295&gt;:   mov    0x88(%rsp),%rdi\n   0x000000000047f58f &lt;+303&gt;:   mov    0xe0(%rsp),%r9\n   0x000000000047f597 &lt;+311&gt;:   mov    0xa29f2(%rip),%rbx        # 0x521f90 &lt;os.Stdout&gt;\n   0x000000000047f59e &lt;+318&gt;:   lea    0x34cb3(%rip),%rax        # 0x4b4258 &lt;go.itab.*os.File,io.Writer&gt;\n   0x000000000047f5a5 &lt;+325&gt;:   call   0x478ca0 &lt;fmt.Fprintf&gt;\n   0x000000000047f5aa &lt;+330&gt;:   mov    %rax,0x60(%rsp)\n   0x000000000047f5af &lt;+335&gt;:   mov    %rbx,0xb0(%rsp)\n   0x000000000047f5b7 &lt;+343&gt;:   mov    %rcx,0xb8(%rsp)\n   0x000000000047f5bf &lt;+351&gt;:   mov    0x60(%rsp),%rdx\n   0x000000000047f5c4 &lt;+356&gt;:   mov    %rdx,0x68(%rsp)\n   0x000000000047f5c9 &lt;+361&gt;:   mov    0xb0(%rsp),%rdx\n   0x000000000047f5d1 &lt;+369&gt;:   mov    0xb8(%rsp),%r10\n   0x000000000047f5d9 &lt;+377&gt;:   mov    %rdx,0xc0(%rsp)\n   0x000000000047f5e1 &lt;+385&gt;:   mov    %r10,0xc8(%rsp)\n   0x000000000047f5e9 &lt;+393&gt;:   mov    0x68(%rsp),%rdx\n   0x000000000047f5ee &lt;+398&gt;:   mov    %rdx,0x40(%rsp)\n   0x000000000047f5f3 &lt;+403&gt;:   mov    0xc0(%rsp),%rdx\n   0x000000000047f5fb &lt;+411&gt;:   mov    0xc8(%rsp),%r10\n   0x000000000047f603 &lt;+419&gt;:   mov    %rdx,0x90(%rsp)\n   0x000000000047f60b &lt;+427&gt;:   mov    %r10,0x98(%rsp)\n   0x000000000047f613 &lt;+435&gt;:   jmp    0x47f615 &lt;main.main+437&gt;\n   0x000000000047f615 &lt;+437&gt;:   mov    0xe8(%rsp),%rbp\n   0x000000000047f61d &lt;+445&gt;:   add    $0xf0,%rsp\n   0x000000000047f624 &lt;+452&gt;:   ret\n   0x000000000047f625 &lt;+453&gt;:   call   0x458980 &lt;runtime.morestack_noctxt&gt;\n   0x000000000047f62a &lt;+458&gt;:   jmp    0x47f460 &lt;main.main&gt;</code>\n        </deckgo-highlight-code>\n<p>...굉장히 쓸데없이 길게 코드가 나오는 걸 볼 수 있다.\n일단 sum 함수 자체가 사라졌고(대충 <code>mov    $0x2, %eax</code>로 최적화 당한 듯 하다),\n스택에 값을 엄청 넣었다 뺐다를 반복하고 있다.</p>\n<p>다른 컴파일러들과 비교해서 <a href=\"https://dr-knz.net/go-calling-convention-x86-64.html\">어떻게 다른지를 정리한 글</a>을 찾았다.\n해당 글에 의하면, 인자와 반환값은 항상 스택에 들어가고, 따라서 memory-heavy 하다는 의견을 내고 있다.</p>\n<h2>왜 이런 일이?</h2>\n<p>Go는 llvm 기반이 아니다(!). 정확히는 gccgo와 golang-go 두 가지 컴파일러가 있는데, golang-go를 일반적으로 사용한다.\n이 컴파일러는 자체 런타임이 결합된 네이티브 머신 코드를 사용한다.\n그래서 다른 언어들과 차이가 날 수 밖에 없다.</p>\n<p>따라서, Go로 컴파일 한다는 것은 리버싱을 효과적으로 방해할 수 있는 훌륭한 수단이 되어 버렸다.\n앞으로 분석당하기 싫은 프로그램을 만들고 싶다면 Go로 짜 보면 괜찮을지도 모르겠다.</p>\n<h2>Reference</h2>\n<p><a href=\"https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf\">The 64 bit x86 C Calling Convention</a></p>\n<p><a href=\"https://go.dev/doc/install/gccgo\">Setting up and using gccgo</a></p>\n<p><a href=\"https://dr-knz.net/go-calling-convention-x86-64.html\">The Go low-level calling convention on x86-64</a></p>","frontmatter":{"title":"Go로 짜면 리버싱이 어려운 이유","date":"August 06, 2023","description":"Golang은 표준 Calling Convention을 따르지 않는다."}},"previous":{"fields":{"slug":"/how-to-know-webapp/"},"frontmatter":{"title":"이 앱이 웹앱인지 아닌지 어떻게 알 수 있을까?"}},"next":{"fields":{"slug":"/about/"},"frontmatter":{"title":"About"}}},"pageContext":{"id":"2a8416d8-e457-574a-9747-7e11c17d1ae4","previousPostId":"3e9d17b6-40ca-5237-b89e-0ed412d0240b","nextPostId":"2d6f7e10-7009-587e-8879-e07132c679c6"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}