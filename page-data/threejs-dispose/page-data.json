{"componentChunkName":"component---src-templates-blog-post-js","path":"/threejs-dispose/","result":{"data":{"site":{"siteMetadata":{"title":"블로그 공사중"}},"markdownRemark":{"id":"3bdd47f6-b1f4-5502-988d-8101103e4639","excerpt":"threejs에서 dispose를 안 하면 gc가 제대로 수거하지 못 한다. dispose() 명령어를 이용해서 명시적으로 제거해야 한다.\n링크 기하학은 속성 집합으로 정의된 꼭짓점 정보를 표시하는데, three.js는 속성마다 하나의 WebGLBuffer…","html":"<p>threejs에서 dispose를 안 하면 gc가 제대로 수거하지 못 한다. dispose() 명령어를 이용해서 명시적으로 제거해야 한다.\n<a href=\"https://threejs.org/docs/#manual/ko/introduction/How-to-dispose-of-objects\">링크</a></p>\n<blockquote>\n<p>기하학은 속성 집합으로 정의된 꼭짓점 정보를 표시하는데, three.js는 속성마다 하나의 WebGLBuffer 유형의 대상을 만들어 내부에 저장합니다. 이러한 개체는 BufferGeometry.dispose를 호출할 때만 폐기됩니다. 만약 애플리케이션에서 기하학을 더이상 사용하지 않는다면, 이 방법을 실행하여 모든 관련 자원을 폐기하세요.</p>\n</blockquote>\n<p>왜 Three.js에서는 dispose()를 해야만 지울 수 있는걸까? Three.js에서 dispose()를 하면 어떤 일이 일어날까?</p>\n<h2>dispose()</h2>\n<p>대부분의 만들어져 있는 Object 코드들을 보면, dispose() 함수에 다음과 같이 오버라이딩을 한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/helpers/Box3Helper.js\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }</code>\n        </deckgo-highlight-code>\n<p>각각의 geometry와 material에 dispose()를 실행하는데, geometry부터 확인해 보자.</p>\n<h2>Geometry</h2>\n<p><code>src/core/BufferGeometry.js</code>를 보면,</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">dispose() {\n  this.dispatchEvent( { type: &#39;dispose&#39; } );\n}</code>\n        </deckgo-highlight-code>\n<p>다음과 같이 dispose 이벤트를 dispatch한다.\n그럼 어디서 저 이벤트를 받을까?</p>\n<p>찾아보니 다음과 같은 파일들에서 이벤트를 받고 있다:</p>\n<ul>\n<li><code>src/renderers/WebGLRenderer.js</code></li>\n<li><code>src/renderers/webgl/WebGLCubeMaps.js</code></li>\n<li><code>src/renderers/webgl/WebGLCubeUVMaps.js</code></li>\n<li><code>src/renderers/webgl/WebGLGeometries.js</code></li>\n<li><code>src/renderers/webgl/WebGLMorphtargets.js</code></li>\n<li><code>src/renderers/webgl/WebGLObjects.js</code></li>\n<li><code>src/renderers/webgl/WebGLTextures.js</code></li>\n<li><code>src/renderers/webgl/WebGLUniformsGroups.js</code></li>\n</ul>\n<p>그 중 geometry는 WebGLGeometries.js에서 관리한다:</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/renderers/webgl/WebGLGeometries.js\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n  const geometries = {};\n  const wireframeAttributes = new WeakMap();\n\n  function get( object, geometry ) {\n    if ( geometries[ geometry.id ] === true ) return geometry;\n    geometry.addEventListener( &#39;dispose&#39;, onGeometryDispose );\n    geometries[ geometry.id ] = true;\n    info.memory.geometries ++;\n    return geometry;\n  }\n\n  function onGeometryDispose( event ) {\n    const geometry = event.target;\n    if ( geometry.index !== null ) {\n      attributes.remove( geometry.index );\n    }\n    for ( const name in geometry.attributes ) {\n      attributes.remove( geometry.attributes[ name ] );\n    }\n\n    geometry.removeEventListener( &#39;dispose&#39;, onGeometryDispose );\n\n    delete geometries[ geometry.id ];\n    const attribute = wireframeAttributes.get( geometry );\n    if ( attribute ) {\n      attributes.remove( attribute );\n      wireframeAttributes.delete( geometry );\n    }\n    bindingStates.releaseStatesOfGeometry( geometry );\n    if ( geometry.isInstancedBufferGeometry === true ) {\n      delete geometry._maxInstanceCount;\n    }\n    //\n    info.memory.geometries --;\n  }\n\n...</code>\n        </deckgo-highlight-code>\n<p>내부 <code>geometries</code>와 <code>wireframeAttributes</code>에서 값을 제거하고,\n그리고 <code>bindingStates.releaseStatesOfGeometry()</code>를 호출한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/renderers/webgl/WebGLBindingStates.js\n\n  function releaseStatesOfGeometry( geometry ) {\n    if ( bindingStates[ geometry.id ] === undefined ) return;\n    const programMap = bindingStates[ geometry.id ];\n    for ( const programId in programMap ) {\n      const stateMap = programMap[ programId ];\n      for ( const wireframe in stateMap ) {\n        deleteVertexArrayObject( stateMap[ wireframe ].object );\n        delete stateMap[ wireframe ];\n      }\n      delete programMap[ programId ];\n    }\n    delete bindingStates[ geometry.id ];\n  }\n\n  function deleteVertexArrayObject( vao ) {\n    if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\n    return extension.deleteVertexArrayOES( vao );\n  }</code>\n        </deckgo-highlight-code>\n<p><code>releaseStatesOfGeometry()</code>에서 바인딩 되어있는 <code>programMap</code>을 제거하고,\n<code>deleteVertexArray()</code>를 호출해서 vertex를 제거한다(WebGL API이다)</p>\n<ul>\n<li>이 부분이 중요, 크롬 기준으로 <code>delete bindingStates[ geometry.id ];</code>로 bindingStates 안에서 지우기만 해도 메모리 누수가 생기지 않는다.</li>\n</ul>\n<h2>Material</h2>\n<p>Material은 어떨까?\n똑같이 dispatchEvent()를 트리거한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/materials/Material.js\n  dispose() {\n    this.dispatchEvent( { type: &#39;dispose&#39; } );\n  }</code>\n        </deckgo-highlight-code>\n<p>그리고 <code>src/renderers/WebGLRenderer.js</code> 에서 받는다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/renderers/WebGLRenderer.js\n  function onMaterialDispose( event ) {\n    const material = event.target;\n    material.removeEventListener( &#39;dispose&#39;, onMaterialDispose );\n    deallocateMaterial( material );\n  }\n\n  // Buffer deallocation\n  function deallocateMaterial( material ) {\n    releaseMaterialProgramReferences( material );\n    properties.remove( material );\n  }\n\n  function releaseMaterialProgramReferences( material ) {\n    const programs = properties.get( material ).programs;\n    if ( programs !== undefined ) {\n      programs.forEach( function ( program ) {\n        programCache.releaseProgram( program );\n      } );\n      if ( material.isShaderMaterial ) {\n        programCache.releaseShaderCache( material );\n      }\n    }\n  }</code>\n        </deckgo-highlight-code>\n<p>properties: <code>src/renderers/webgl/WebGLProperties.js</code> 에서 import한 <code>WebGLProperties()</code>이며, WeakMap이다.</p>\n<p>WeakMap은 Map처럼 key-value object인데, key에는 객체 또는 등록되지 않은 symbol이어야 한다는 점이 큰 차이점이다.\n그리고 WeakMap에서 참조하고 있는 key는 gc 수집 대상이다.\n따라서 WeakMap에서만 참고하고 있는 객체는 gc한테 수거당한다.</p>\n<p>해당 material이 있는 program의 캐시를 지우고, shader cache까지 지우는 걸 확인할 수 있다(<code>WebGLShaderCache</code> 안에서 <code>Map</code>으로 관리하고 있다).</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/renderers/webgl/WebGLPrograms.js\nprograms = []\n...\nfunction releaseProgram( program ) {\n  if ( -- program.usedTimes === 0 ) {\n    // Remove from unordered set\n    const i = programs.indexOf( program );\n    programs[ i ] = programs[ programs.length - 1 ];\n    programs.pop();\n\n    // Free WebGL resources\n    program.destroy();\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같은 방법으로 리스트에서 제거한다.</p>\n<ul>\n<li><code>splice()</code> 보다 이 방법이 더 빨라서 해당 방법으로 제거하는 것으로 보인다.</li>\n</ul>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/renderers/webgl/WebGLProgram.js\n\nthis.destroy = function () {\n\n  bindingStates.releaseStatesOfProgram( this );\n\n  gl.deleteProgram( program );\n  this.program = undefined;\n\n};</code>\n        </deckgo-highlight-code>\n<p>program.destry()에선 gl.deleteProgram()을 호출한다(WebGL API이다).</p>\n<h2>Object</h2>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// src/renderers/webgl/WebGLObjects.js\nfunction dispose() {\n  updateMap = new WeakMap();\n}\n\nfunction onInstancedMeshDispose( event ) {\n  const instancedMesh = event.target;\n  instancedMesh.removeEventListener(\n    &#39;dispose&#39;, onInstancedMeshDispose\n  );\n  attributes.remove( instancedMesh.instanceMatrix );\n  if ( instancedMesh.instanceColor !== null ) {\n    attributes.remove( instancedMesh.instanceColor );\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>Control</h2>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// OrbitControls.js\nthis.dispose = function () {\n  scope.domElement.removeEventListener( &#39;contextmenu&#39;, onContextMenu );\n\n  scope.domElement.removeEventListener( &#39;pointerdown&#39;, onPointerDown );\n  scope.domElement.removeEventListener( &#39;pointercancel&#39;, onPointerUp );\n  scope.domElement.removeEventListener( &#39;wheel&#39;, onMouseWheel );\n\n  scope.domElement.removeEventListener( &#39;pointermove&#39;, onPointerMove );\n  scope.domElement.removeEventListener( &#39;pointerup&#39;, onPointerUp );\n\n\n  if ( scope._domElementKeyEvents !== null ) {\n\n    scope._domElementKeyEvents.removeEventListener( &#39;keydown&#39;, onKeyDown );\n    scope._domElementKeyEvents = null;\n\n  }\n\n  //scope.dispatchEvent( { type: &#39;dispose&#39; } ); // should this be added here?\n\n};</code>\n        </deckgo-highlight-code>\n<p>control 관련 코드들에서는 추가적으로 removeEventListener()를 호출해서 정리한다.</p>\n<h2>결론</h2>\n<p>geometry의 경우 내부 <code>geometries</code> array와, <code>WebGLBindingStates</code>의 내부 프로퍼티 <code>bindingStates</code>에 있는 <code>programMap</code>을 지우고,</p>\n<p>material의 경우 관련 정보는 다 WeakMap()에 저장되어 있고, dispose를 할 때도 program cache와 shader cache에서 값을 삭제한다.</p>\n<p>따라서 dispose()를 한 뒤 다시 사용해도 런타임 에러는 발생하지 않는다(캐시에 없기 때문에 다시 만들 뿐).</p>\n<p>Spector.js 등으로 찍어보면 geometry, texture를 dispose 안 한 경우 어떤 일이 일어나는지 쉽게 확인 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 519px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/03a1f09b9defd398d5c9e9e18c275989/b23ad/spector.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 123.41772151898734%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACGUlEQVR42qVU2XLiMBD0hwTQLcvG+HY2sAkJmDXXxuQols3//0dvWQae9iXiYcrSaKqlnum2J/wAwoSQ4QTCjMG1sXsbl7U2/bkfQgRdjW9r7bkfQnY5qUApgSfDGDrOoZMSpniAmmTQaQk/u4eKUuikgI4L+MW0X6dlX5MU9lzFua2VYQShfHiMc4gohxgnGA6HoITYm/ov7dd2P/pPnl5zjFIwxuEJzhDHMaqfc8ye5lBB2FPq6Hw7fHiaEZRG4Nd6g6+vvzDGB+luZMwpPEkJslBjs9uhfX2FUvIK2FP6XniSERRjje3+N3a7LYLA3PjCjnKgsFzWOBxalGWB4XB0G2BulKV8Op1wX5V22s6AqqNsJFZNg/f3N2RZitFodO3htwE1p5jqEep6ic/jES/P8yug0wsFowjoAGk8QVXkiKLIipU5TNhOmTIOPk5BTQQaxCBc9Ldx7hTWKZM4wcNzjeliBdUZXWmrepewTikMx7pp8Pl2QJFn5ylTd2GnRmK5qtG2B1RVedtQOtnkgcJ6s8Of49ECXnToJBtrvc7Lmx32+z1ms+ltL7w4ZVmv8PH5gbpegJAbKXdebpo1Doc3rOr6xh5yih+aYLFYoG1bbLdbCMGd+nemTBGx3inz+RMenx4hpXAH7JxCgwmIDjEgDIO7Oyf9XXVonZJkqF4aJNXD2SXG3SndzyGUDFmWIYrGII5UL5T/AcW71ifM7fUJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"spector.png\"\n        title=\"\"\n        src=\"/static/03a1f09b9defd398d5c9e9e18c275989/b23ad/spector.png\"\n        srcset=\"/static/03a1f09b9defd398d5c9e9e18c275989/c26ae/spector.png 158w,\n/static/03a1f09b9defd398d5c9e9e18c275989/6bdcf/spector.png 315w,\n/static/03a1f09b9defd398d5c9e9e18c275989/b23ad/spector.png 519w\"\n        sizes=\"(max-width: 519px) 100vw, 519px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>의문이 하나 드는데, scene에서 없어진 material은 weakmap 외의 어느 곳에서도 참조되고 있지 않기 때문에, gc가 수거해가지 않나? 하는 점이다.\n실제로 three.js example 중 memory test를 돌릴 때, geometry만 dispose()해 줘도\nchrome expector에서 메모리 누수가 발생하는 것으로 보이지 않았다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/68b5ee69bbcb588e0215ebecdefdf4ba/29114/no_dispose_material_.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.139240506329116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABR0lEQVR42m2SW08CMRSE+f//wgffTYw3RNEXA0SiYAIoGgV2uS1sF9ql7fYypiULC2GS5qRt+mV65pSkMlBKwVoLJ1eLKz9zklIijglWlCGhKUiSIooZ4hUFoQxLkqCEgoqQY7gTFwL94Rg/QYhw9IfBYohwOcB0EmI2ixCROUonHZk1rCEHYKcNF7hp9nH12kOtVsd1p45K5wWNZguN91+0g2DrsAgz+huSn0PyM+iscQDkXODpY4T7ToByb4Jqd4q79hSPX2NUPkd47BaA20qhZNmDtHpDJm9h9HDnVAiB+SIGZQyMUWz4BkJwcM79ndsfAI2JoOQDtGpBqzaUfIbW/fzj/tFkFoEka1CW+ha4vrJ044MiK3rs0HpIJi6QiUvv0FqGPCchpE/6WO6dMQbG2H3Ke6iEympQsroLpjg2UmYnJyDXPyDAZ9B7rwiZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"no_dispose_material.png\"\n        title=\"\"\n        src=\"/static/68b5ee69bbcb588e0215ebecdefdf4ba/f058b/no_dispose_material_.png\"\n        srcset=\"/static/68b5ee69bbcb588e0215ebecdefdf4ba/c26ae/no_dispose_material_.png 158w,\n/static/68b5ee69bbcb588e0215ebecdefdf4ba/6bdcf/no_dispose_material_.png 315w,\n/static/68b5ee69bbcb588e0215ebecdefdf4ba/f058b/no_dispose_material_.png 630w,\n/static/68b5ee69bbcb588e0215ebecdefdf4ba/40601/no_dispose_material_.png 945w,\n/static/68b5ee69bbcb588e0215ebecdefdf4ba/78612/no_dispose_material_.png 1260w,\n/static/68b5ee69bbcb588e0215ebecdefdf4ba/29114/no_dispose_material_.png 1920w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a6b0bdea2b4fa6d18b3856335f541c3a/29114/no_dispose.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.30379746835443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABOUlEQVR42nWSC2uDMBzE/f5fq4ONsYJbO2i3UfAVtGoexkcSG2+k1j5se/AnIZBfjst5yhxgjIHTMAx3M507aa1RFgWEqMCrGoxJZHmFggqUvEJeMng4aX55/oCTUgq7OMWOEERJgLCMENMIaZ4gzffYsxTeIyfHMzvcQCfg8ucXH5stkvUKfvAFP/CxWX1jvUzw+ZeNDq8vWRdBIWFyCduZm4cc0A9DvEUhFkGMxY7gNSB4CWK8kxh+mlyA09rzFqas0bMGPW0w9BZTCJ1SCEmBPeUgNEPZlKgURWMYGsMhNZ0BezuCRItedMe91f05U/cpJM1AGUctG7StQttqSNmBixqUyQcOxehwcjnYi0MH7Dp1jshOq7U4nOb+lw92BBbymOe8NsbouzZcy3tWmXl1JqCbZ5118w8iDbvG/fy5GQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"no_dispose.png\"\n        title=\"\"\n        src=\"/static/a6b0bdea2b4fa6d18b3856335f541c3a/f058b/no_dispose.png\"\n        srcset=\"/static/a6b0bdea2b4fa6d18b3856335f541c3a/c26ae/no_dispose.png 158w,\n/static/a6b0bdea2b4fa6d18b3856335f541c3a/6bdcf/no_dispose.png 315w,\n/static/a6b0bdea2b4fa6d18b3856335f541c3a/f058b/no_dispose.png 630w,\n/static/a6b0bdea2b4fa6d18b3856335f541c3a/40601/no_dispose.png 945w,\n/static/a6b0bdea2b4fa6d18b3856335f541c3a/78612/no_dispose.png 1260w,\n/static/a6b0bdea2b4fa6d18b3856335f541c3a/29114/no_dispose.png 1920w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span> (비교용 - dispose를 하지 않았을 때)</p>\n<p>WebGL spector 등으로 찍어봐도 <code>material.dispose();</code> 만 주석처리 한 경우에는 메모리에 별 다른 변화를 확인할 수 없었다. BasicMaterial이라 그런가 싶다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 520px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0a5e920cb16b9a538b5c017806731dc7/69902/spector_no_dispose_material.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 124.0506329113924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABr0lEQVR42q1VyXajMBDkQyZBS2sBJEAotvEyp7nM//9QzWsZj5OXl4vwoWg2lVrq6lJjQoJfVrjlBH+4woQZLh3g8wo3Zbh0hJ0yfL7ApVP5147LFtP2bQX5HkprNOQ8TBdA3fCE759xg+kjyA93uO4ZH2NcB20sGqUUXD6XTPgFz6I0fYr06Vn/8F1DEUGTQUNKIsceYV6gyEBbV4hr0ZBscRws5jmhfX+HkhJyBxotBXJvMU4T2rYFb8EeNEa2OEeHOS3/CXmmakItJVavMMYAKcQuskLIF7IWxMWwbstQ1O8hExRxsrjTsWiKy19dZSMF1rHD5fYbUuldkimEjyqv6wohxC7JlCWTFDgEh/PlUghfIBuBc7C43m67K3yXDbeeaZHnCXwvtyxryRvJg/0A6e6OwhV+kNW1npIYU0Y43eDmD5g+gC2tWFMFyh4eesIYI9q3X1BqZ6ewbD6G771cLZuS4eAwTvNrzIF1eA0WKS2v0SEb6kgC3trNXNUuk20knwdxgY4Z2vXFaXZlyGfKFCOuf/4iHVcosiDf1cuGdei0RAgDvPdfOqVmyf8AwgjGvhUsiLsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"spector_no_dispose_material.png\"\n        title=\"\"\n        src=\"/static/0a5e920cb16b9a538b5c017806731dc7/69902/spector_no_dispose_material.png\"\n        srcset=\"/static/0a5e920cb16b9a538b5c017806731dc7/c26ae/spector_no_dispose_material.png 158w,\n/static/0a5e920cb16b9a538b5c017806731dc7/6bdcf/spector_no_dispose_material.png 315w,\n/static/0a5e920cb16b9a538b5c017806731dc7/69902/spector_no_dispose_material.png 520w\"\n        sizes=\"(max-width: 520px) 100vw, 520px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>Reference</h2>\n<p>WeakMap이 알고 싶다 - <a href=\"https://ui.toast.com/posts/ko_20210901\">https://ui.toast.com/posts/ko_20210901</a></p>\n<p>Spector.js - <a href=\"https://spector.babylonjs.com/\">https://spector.babylonjs.com/</a></p>","frontmatter":{"title":"Three.js 에서 dispose()는 어떻게 작동할까?","date":"April 28, 2023","description":"threejs에서 dispose를 안 하면 gc가 제대로 수거하지 못 한다. 왜 그런걸까?"}},"previous":{"fields":{"slug":"/unist-pixel-dungeon/"},"frontmatter":{"title":"UNIST Pixel Dungeon"}},"next":null},"pageContext":{"id":"3bdd47f6-b1f4-5502-988d-8101103e4639","previousPostId":"c771ddb0-7a9a-5c6f-85da-95a5da4b84cb","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}